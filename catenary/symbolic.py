"""Sympy version!"""

import json
import pickle
from functools import partial

import jax as j
import jax.numpy as np
import sympy as s
from jax.config import config
from pkg_resources import resource_filename
from sympy.utilities.lambdify import (MODULES, NUMPY, NUMPY_DEFAULT,
                                      NUMPY_TRANSLATIONS)

import catenary.single as cs

# Attempt to get this working more quickly. I think it does!
MODULES['jax'] = (NUMPY, NUMPY_DEFAULT, NUMPY_TRANSLATIONS, (
    "import jax.numpy; from jax.numpy import *; from jax.numpy.linalg import *",
))

FILEPATH = "single_matrix_correlators.json"
PICKLEPATH = "smc.pickle"

config.update('jax_enable_x64', True)


def symbolic_path():
  """Stable path where we keep our correlators."""
  return resource_filename('catenary.resources', FILEPATH)


def pickle_path():
  """Stable path where we keep our correlators."""
  return resource_filename('catenary.resources', PICKLEPATH)


# Exact Solution


def generate_t2_exact():
  """Generates a symbolic expression for the exact solution to t2, given a g.

  """
  g = s.symbols('g')
  a_squared = 1 / (6 * g) * (s.sqrt(1 + (12 * g)) - 1)
  numerator = a_squared * (4 - a_squared)
  expr = numerator / 3
  return expr


# This is an evaluated version of the expression.
t2_exact_expr = generate_t2_exact()


def t2_exact_sympy(g):
  """Given some exact value for g, evaluate and simplifies a symbolic version of
  g.

  Call evalf() on the result to get a float. For example, this stays symbolic:

  t2_exact_sympy(s.Rational(12, 10))

  All three of these give floats:
  t2_exact_sympy(s.Rational(12, 10)).evalf()
  t2_exact_sympy(1.2)
  t2_exact_sympy(1.2).evalf()

  """
  return s.simplify(t2_exact_expr.subs(s.symbols('g'), g))


# This version actually evaluates numerically.
t2_exact_jax = s.lambdify([s.symbols('g')], t2_exact_expr, 'jax')

# Correlators


def t_k_plus_three(k):
  """Generates the (k + 3)th term of the loop equation recursion for the single matrix
  case.

  """
  alpha, g = s.symbols('alpha g')
  l = s.symbols('l', cls=s.Idx)
  t = s.IndexedBase('t')
  term = 1 / g * (s.Sum(alpha**4 * t[l] * t[k - l - 1],
                        (l, 0, k - 1)) - (alpha**2 * t[k + 1]))

  return t[k + 3], term


def correlator_expressions(n):
  """This gets us the whole list of expressions!

  This will read in strings of expressions:
  s.sympify(expr_string, locals={"t": s.IndexedBase('t')})

  """
  t = s.IndexedBase('t')
  subs = [(t[0], 1), (t[1], t[1]), (t[2], t[2])]

  for i in range(n):
    k, v = t_k_plus_three(i)
    subs.append((k, s.simplify(v.doit().subs(subs))))
    print(i, subs[-1])

  return dict(subs)


def persist_correlators(n, filename=symbolic_path()):
  """Saves correlators to JSON"""
  m = correlator_expressions(n)
  skv = {str(k): str(v) for k, v in m.items()}
  with open(filename, 'w') as f:
    json.dump(skv, f, indent=2)


def persist_to_pickle(m):
  with open(pickle_path(), 'wb') as f:
    pickle.dump(m, f, protocol=pickle.HIGHEST_PROTOCOL)


def load_from_pickle():
  """This is MUCH faster. Fine if we do this a single time."""
  with open(pickle_path(), 'rb') as f:
    return pickle.load(f)


def load_correlators(filename=symbolic_path()):
  """Returns a dict of k => t_k generated by loading the stored data.

  TODO update this to make it cache and generate.

  """
  m = None
  t = s.IndexedBase('t')

  def parse(expr):
    return s.sympify(expr, locals={"t": t})

  with open(filename, 'r') as f:
    pairs = json.load(f).items()
    m = {parse(k).indices[0]: parse(v) for k, v in pairs}

  return m


def generate_functions(m, n):
  alpha, g = s.symbols('alpha g')
  t = s.IndexedBase('t')

  expr = [v for i, v in sorted(m.items()) if i < n]
  f = s.lambdify([alpha, g, t[1], t[2]], expr, 'jax')

  def ret(alpha, g, t1, t2):
    """Here's where we take care of the s1 s2 conversion."""
    s1 = np.multiply(t1, alpha)
    s2 = np.multiply(t2, np.square(alpha))
    return np.array(f(alpha, g, s1, s2))

  return j.jit(ret, static_argnums=(0, 1, 2))


def mpmath_fn(m, n):
  alpha, g = s.symbols('alpha g')
  t = s.IndexedBase('t')

  expr = [v for i, v in sorted(m.items()) if i < n]
  f = s.lambdify([alpha, g, t[1], t[2]], expr, 'mpmath')

  def ret(alpha, g, t1, t2):
    """Here's where we take care of the s1 s2 conversion."""
    s1 = np.multiply(t1, alpha)
    s2 = np.multiply(t2, np.square(alpha))
    return np.array(f(alpha, g, s1, s2))

  return ret


MAX_N = 20
single_matrix_correlators = generate_functions(load_from_pickle(),
                                               2 * MAX_N - 1)


@partial(j.jit, static_argnums=(0, 1, 2, 3))
def inner_product_matrix(alpha, g, t1, t2):
  """Returns the... inner product matrix of correlators for the single matrix
  model.

  We do NOT need to do the transformation of t2 by alpha for this, vs the
  recursive solution. Since that happens already inside the equations.

  """
  xs = single_matrix_correlators(alpha, g, t1, t2)
  return cs.sliding_window_m(xs, MAX_N)
