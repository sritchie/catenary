"""Sympy version!"""

import json
import pickle
from functools import partial

import jax as j
import jax.numpy as np
import jax.numpy.linalg as la
import sympy as s
from jax.config import config
from pkg_resources import resource_filename
from sympy.utilities.lambdify import (MODULES, NUMPY, NUMPY_DEFAULT,
                                      NUMPY_TRANSLATIONS)

import catenary.single as cs

# Attempt to get this working more quickly. I think it does!
MODULES['jax'] = (NUMPY, NUMPY_DEFAULT, NUMPY_TRANSLATIONS, (
    "import jax.numpy; from jax.numpy import *; from jax.numpy.linalg import *",
))

FILEPATH = "smc.json"
PICKLEPATH = "smc.pickle"

config.update('jax_enable_x64', True)


def symbolic_path():
  """Stable path where we keep our correlators."""
  return resource_filename('catenary.resources', FILEPATH)


def pickle_path():
  """Stable path where we keep our correlators."""
  return resource_filename('catenary.resources', PICKLEPATH)


# Exact Solution


def generate_t2_exact():
  """Generates a symbolic expression for the exact solution to t2, given a g.

  """
  g = s.symbols('g')
  a_squared = 1 / (6 * g) * (s.sqrt(1 + (12 * g)) - 1)
  numerator = a_squared * (4 - a_squared)
  expr = numerator / 3
  return expr


# This is an evaluated version of the expression.
t2_exact_expr = generate_t2_exact()


def t2_exact_sympy(g):
  """Given some exact value for g, evaluate and simplifies a symbolic version of
  g.

  Call evalf() on the result to get a float. For example, this stays symbolic:

  t2_exact_sympy(s.Rational(12, 10))

  All three of these give floats:
  t2_exact_sympy(s.Rational(12, 10)).evalf()
  t2_exact_sympy(1.2)
  t2_exact_sympy(1.2).evalf()

  """
  return s.simplify(t2_exact_expr.subs(s.symbols('g'), g))


# This version actually evaluates numerically.
t2_exact_jax = s.lambdify([s.symbols('g')], t2_exact_expr(), 'jax')

# Correlators


def t_k_plus_three(k):
  """Generates the (k + 3)th term of the loop equation recursion for the single matrix
  case.

  """
  alpha, g = s.symbols('alpha g')
  l = s.symbols('l', cls=s.Idx)
  t = s.IndexedBase('t')
  term = 1 / g * (s.Sum(alpha**4 * t[l] * t[k - l - 1],
                        (l, 0, k - 1)) - (alpha**2 * t[k + 1]))

  return t[k + 3], term


def correlator_expressions(n):
  """This gets us the whole list of expressions!

  This will read in strings of expressions:
  s.sympify(expr_string, locals={"t": s.IndexedBase('t')})

  """
  t = s.IndexedBase('t')
  subs = [(t[0], 1), (t[1], t[1]), (t[2], t[2])]

  for i in range(n):
    k, v = t_k_plus_three(i)
    subs.append((k, s.simplify(v.doit().subs(subs))))
    print(i, subs[-1])

  return dict(subs)


def persist_correlators(n, filename=symbolic_path()):
  """Saves correlators to JSON"""
  m = correlator_expressions(n)
  skv = {str(k): str(v) for k, v in m.items()}
  with open(filename, 'w') as f:
    json.dump(skv, f, indent=2)


def persist_to_pickle(m):
  with open(pickle_path(), 'wb') as f:
    pickle.dump(m, f, protocol=pickle.HIGHEST_PROTOCOL)


def load_from_pickle():
  """This is MUCH faster. Fine if we do this a single time."""
  with open(pickle_path(), 'rb') as f:
    return pickle.load(f)


def load_correlators(filename=symbolic_path()):
  """Returns a dict of k => t_k generated by loading the stored data.

  TODO update this to make it cache and generate.

  """
  m = None
  t = s.IndexedBase('t')

  def parse(expr):
    return s.sympify(expr, locals={"t": t})

  with open(filename, 'r') as f:
    pairs = json.load(f).items()
    m = {parse(k).indices[0]: parse(v) for k, v in pairs}

  return m


def generate_functions(m, n):
  alpha, g = s.symbols('alpha g')
  t = s.IndexedBase('t')

  expr = [v for i, v in sorted(m.items()) if i < n]
  f = s.lambdify([alpha, g, t[1], t[2]], expr, 'jax')

  def ret(alpha, g, t1, t2):
    return np.array(f(alpha, g, t1, t2))

  return j.jit(ret, static_argnums=(0, 1, 2))


MAX_N = 20
single_matrix_correlators = generate_functions(load_from_pickle(),
                                               2 * MAX_N - 1)


@partial(j.jit, static_argnums=(0, 1, 2, 3))
def inner_product_matrix(n, alpha, g, t1, t2):
  """Returns the... inner product matrix of correlators for the single matrix
  model.

  """
  s1 = np.multiply(t1, alpha)
  s2 = np.multiply(t2, np.square(alpha))
  xs = single_matrix_correlators(alpha, g, s1, s2)
  return cs.sliding_window_m(xs, MAX_N)


def checker():
  for g in np.arange(-1 / 12, 1, 0.1):
    t2 = cs.t2_exact(g)
    print(la.eigvals(inner_product_matrix(8, 1, g, 0, t2))[:4])


# Report on what I've tried. I've got the symbolic expressions working. But
# sympy seems to be screwing us here. These are the correlator values at
#
#
# xs = single_matrix_correlators(1, -0.02, 0, cs.t2_exact(-0.02))
#
# That I get for sympy...

recursive = [
    1.0, 0.0, 1.044103676767703, -0.0, 2.2051838383851496, -0.0,
    5.848824242487183, -0.0, 17.415203893852382, -0.0, 55.633715083235735, -0.0,
    186.34568708790127, -0.0, 645.8117350396407, -0.0, 2296.471528260753, -0.0,
    8331.87759593577, -0.0, 30720.98803228173, -0.0, 114795.27895371194, -0.0,
    434312.2918507295, -0.0, 1686594.4343380863, -0.0, 7936485.499678843, -0.0,
    100214807.9939317, -0.0, 3714576365.185739, -0.0, 173578339025.64343, -0.0,
    8291489993052.295, -0.0, 396790694318458.1
]

sympy_symbolic = []

sympy_symbolic_alpha = []

sympy_numeric = [
    1.0, 0.0, 1.044103676767703, -0.0, 2.2051838383851496, 0.0,
    5.848824242487183, 0.0, 17.415203893862998, 0.0, 55.63371508293669, 0.0,
    186.34568708440497, 0.0, 645.811735577395, 0.0, 2296.4714630335448, 0.0,
    8331.875557629688, 0.0, 30720.972137727786, 0.0, 114791.5533525885, 0.0,
    434333.6795641596, 0.0, 1696420.5074620347, 0.0, 8618730.314790826, 0.0,
    103661724.98919296, 0.0, 981787330.0747375, 0.0, 318524311132.17017, 0.0,
    8784782650953.0, 0.0, 284108634072034.0
]

mathematica_numeric = []
# And this is what I get with a purely symbolic evaluation in Mathematica:
mathematica_sym = [
    1.0, 0., 1.04410367676770, 0, 2.20518383838514, 0, 5.84882424248666, 0,
    17.4152038938273, 0, 55.6337150820375, 0, 186.345687030548, 0,
    645.811732294551, 0, 2296.47139687255, 0, 8331.87130730283, 0,
    30720.6870394656, 0, 114780.872535612, 0, 433622.757511960, 0,
    1.65359125470976 * 10**6, 0, 6.35685442935001 * 10**6, 0,
    2.46089316375027 * 10**7, 0, 9.58525713864225 * 10**7, 0,
    3.75374826475053 * 10**8, 0, 1.47712752712229 * 10**9, 0,
    5.83772936477801 * 10**9, 0, 2.31609937202489 * 10**10, 0,
    9.22142814908856 * 10**10, 0, 3.68323176771173 * 10**11, 0,
    1.47546779323858 * 10**12, 0, 5.92645669069471 * 10**12, 0,
    2.38634151463011 * 10**13, 0, 9.63075211382459 * 10**13, 0,
    3.89497810253137 * 10**14, 0, 1.57834483760730 * 10**15, 0,
    6.40755554061825 * 10**15, 0, 2.60569658458186 * 10**16, 0,
    1.06132580238142 * 10**17, 0, 4.32936188144616 * 10**17, 0,
    1.76852057797075 * 10**18, 0, 7.23388546233886 * 10**18, 0,
    2.96261825021415 * 10**19, 0, 1.21476509159836 * 10**20
]

# it turns out that mathematica itself is quite unstable!
